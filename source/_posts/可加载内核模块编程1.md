---
title: 可加载内核模块编程1
date: 2018-03-22 19:30:24
tags:
- kernel
- LKM
categories:
- linux
---

由于自己要动手修改virtio源码，需要重新编写位于客户机前端virtio驱动，因此需要了解可加载内核模块（loadable kernel module, LKM）。在网上和书里面找了些资料，总结一下。
<!-- more -->

Linux众多优良特性之一就是可以在运行时扩展内核的功能。而每块可以在运行时添加到（删除）内核的代码称为一个模块。可加载的内核模块包括设备驱动程序。这样使内核可以在不知道硬件如何工作的情况下和硬件进行交互。每个模块由目标代码组成（没有连接成一个完整可执行文件），可以动态连接到运行中的内核中。

### 设备编号

主设备编号和次设备编号

## 重要数据结构

### 文件操作

`struct file_operations`结构或者其一个指针`fops`是可以将一个字符驱动连接到有编号得设备上。位于`<linux/fs.h>`中。结构中得成员大部分负责系统调用实现。
```
struct file_operations scull_fops = {
.owner = THIS_MODULE,
.llseek = scull_llseek,
.read = scull_read,
.write = scull_write,
.ioctl = scull_ioctl,
.open = scull_open,
.release = scull_release,
};
```
这个声明使用标准的C**标记式结构初始化**语法，这个语法是内核首选的，因为它使驱动在结构定义的改变之间更加可移植, 并且, 标记式初始化允许结构成员重新排序；在某种情况下，通过安放经常使用的成员的指针在相同硬件高速存储行中，提高了性能。

### 文件结构

`struct file`或其指针`filp`定义于`<linux/fs.h>`中，位于内核结构，不出现在用户程序中。文件结构代表一个打开的文件，（它不特指设备驱动），由内核在open时创建，并传递给文件操作的任何函数，直到最后关闭，内核释放这个数据结构。

成员函数：
```
void *private_data;
```
open 系统调用设置这个指针为 NULL, 在为驱动调用 open 方法之前. 你可自由使
用这个成员或者忽略它; 你可以使用这个成员来指向分配的数据, 但是接着你必须
记住在内核销毁文件结构之前, 在 release 方法中释放那个内存. private_data
是一个有用的资源, 在系统调用间保留状态信息, 我们大部分例子模块都使用它.


### inode结构

`inode`结构由内核在内部用来表示文件，代表磁盘上的一个文件。`inode`不同于文件描述符的`struct file`文件结构，可能有代表单个文件的多个打开描述符的许多文件结构，但是它们都指向一个单个
inode 结构。

inode 结构包含大量关于文件的信息。作为一个通用的规则，这个结构只有 2 个成员对于编写驱动代码有用：
`dev_t i_rdev`：对于代表设备文件的节点，这个成员包含实际的设备编号。
`struct cdev *i_cdev`：`struct cdev`是内核的内部结构，代表字符设备；这个成员包含一个指针，指向这个结构，当节点指的是一个字符设备文件时。


## 字符设备注册

内核在内部使用类型`struct cdev`的结构体代表字符设备，位于`<linux/cdev.h>`中。用下面的代码来初始化。
```
struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;
```

字符设备经典的注册方法是：
```
int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);
```
这里`major`是感兴趣的主编号，`name`是驱动的名子（出现在`/proc/devices`），`fops`是缺省的`file_operations`结构。
与注册配对的去除设备的方法是：
```
int unregister_chrdev(unsigned int major, const char *name);
```
从主次编号来建立 `dev_t` 数据项的宏定义.
```
dev_t MKDEV(unsigned int major, unsigned int minor);
```


### open函数

```
int (*open)(struct inode *inode, struct file *filp);
```

### release函数

```
int (*release)(struct inode *inode, struct file *filp)
```

### read/write函数

```
ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);
ssize_t write(struct file *filp, const char __user *buff, size_t count, loff_t *offp);
```
 filp 是文件指针，count是请求的传输数据大小。buff 参数指向持有被写入数据的缓存，或者放入新数据的空缓存。最后，offp 是一个指针指向一个“long offset type”对象，它指出用户正在存取的文件位置。返回值是一个“signed size type”。

下面函数可以在用户空间和内核空间拷贝数据。
```
unsigned long copy_to_user(void __user \*to,const void \*from, unsigned long count);
unsigned long copy_from_user(void \*to, const void __user \*from, unsigned long count);
```
位于`<asm/uaccess.h>`。至于实际的设备方法, read 方法的任务是从设备拷贝数据到用户空间(使用copy_to_user), 而 write 法必须从用户空间拷贝数据到设备(使用 copy_from_user)。


## 调试

### printk
`printk` 允许你根据消息的严重程度对其分类，通过附加不同的记录级别或者优先级在消息上。常常用一个宏定义来指示记录级别。
比如
```
printk(KERN_INFO "Hello!\n");
```
记录宏定义扩展成一个字串, 在编译时与消息文本连接在一起;这就是为什么下面的在优先级和格式串之间没有逗号的原因。
有8种可能的记录等级。在`<linux/kernel.h>`里定义。按照严重等级递减顺序依次是：
```
KERN_EMERG
	用于紧急消息, 常常是那些崩溃前的消息.
KERN_ALERT
	需要立刻动作的情形.
KERN_CRIT
	严重情况, 常常与严重的硬件或者软件失效有关.
KERN_ERR
	用来报告错误情况; 设备驱动常常使用 KERN_ERR 来报告硬件故障.
KERN_WARNING
	有问题的情况的警告, 这些情况自己不会引起系统的严重问题.
KERN_NOTICE
	正常情况, 但是仍然值得注意. 在这个级别一些安全相关的情况会报告.
KERN_INFO
	信息型消息。在这个级别, 很多驱动在启动时打印它们发现的硬件的信息.
KERN_DEBUG
	用作调试消息。
```

整数范围0~7，越小表示优先级越高。这里面读取的方式有所不同。基于记录级别，内核可能打印消息到当前控制台，可能是一个文本模式终端，串口，或者是一台并口打印机，如果优先级小于整型值 console_loglevel，消息被递交给控制台，一次一行（除非提供一个新行结尾，否则什么都不发送）。如果klogd 和 syslogd 都在系统中运行， 内核消息被追加到 /var/log/messages （或者另外根据你的 syslogd 配置处理），独立于 console_loglevel，如果 klogd 没有运行，你只有读 /proc/kmsg （用`dmsg` 命令最易做到 ）将消息取到用户空间。当使用 klogd 时，你应当记住，它不会保存连续的同样的行；它只保留第一个这样的行，随后是，它收到的重复行数。

也可以通过文本文件 `/proc/sys/kernel/printk` 读写控制台记录级别。
```
$ cat /proc/sys/kernel/printk
4	4	1	7
```
这个文件有 4 个整型值: 当前记录级别4，适用没有明确记录级别的消息的缺省级别4，允许的最小记录级别1，以及启动时缺省记录级别7。 

## 并发和竞争

### 自旋锁

作为互斥锁，自旋锁只有两个值：上锁和解锁。如果锁是可用的，上锁位被置为并且代码进入临界区；相反，如果这个锁已被获得，代码进入一个紧凑的循环中反复检查这个锁，直到变得可用。

自旋锁原语在`<linux/spinlock.h>`中。一个实际的锁有类型 `spinlock_t`。象任何其他数据结构，一个自旋锁必须初始化。 这个初始化可以在编译时完成`spinlock_t my_lock = SPIN_LOCK_UNLOCKED;`或运行时使用`void spin_lock_init(spinlock_t *lock);`。

在进入临界区钱，必须获得`lock`：
`void spin_lock(spinlock_t *lock);`


在获得自旋锁之前，禁止中断(只在本地处理器)；之前的中断状态保存在 `flags` 里:
`void spin_lock_irqsave(spinlock_t *lock, unsigned long flags); `

获取锁之前禁止软件中断，但是硬件中断留作打开的：
`void spin_lock_bh(spinlock_t *lock);`

当在释放自旋锁时打开中断,可以使用:
`void spin_lock_irq(spinlock_t *lock);`

为释放一个已获得的锁，传递它给:
```
void spin_unlock(spinlock_t *lock);
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
void spin_unlock_irq(spinlock_t *lock);
void spin_unlock_bh(spinlock_t *lock);
```
每个 spin_unlock 变体恢复由对应的 spin_lock 函数锁做的工作。传递给spin_unlock_irqrestore 的 flags 参数必须是传递给 spin_lock_irqsave 的同一个变量。你必须也调用 spin_lock_irqsave 和 spin_unlock_irqrestore 在同一个函数里。







# 参考资料
[1] 深入理解Linux内核
[2] Linux设备驱动程序
[3] [编写Linux内核模块——第一部分：前言](http://www.infoq.com/cn/articles/linux-kernel-module-part01)
[4] [编写Linux内核模块——第二部分：字符设备](http://www.infoq.com/cn/articles/linux-kernel-module-part02)
[5] [标记化结构初始化语法---结构体成员前加小数点](https://blog.csdn.net/ixidof/article/details/7893680)
