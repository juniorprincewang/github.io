---
title: 密码学EXM?
date: 2017-08-06 10:41:42
tags:
- cryptography
- 国产密码
categories:
- security
---


搞安全怎么能离开密码学。武功再高，也怕菜刀。密码学还得一口一口的啃啊。
<!-- more -->

![](../密码学EXM/exm.jpg)

凯撒和栅栏密码

Cipher Block

# base64/32/16编码

原来仅仅听过base64，后来还听到了base32, base16。其实原理都一样，base64、base32、base16可以分别编码转化8位字节为6位、5位、4位。这里重点介绍base64。
Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email via MIME,在XML中存储复杂数据。

编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表。

python的base64模块用于base64/32/16编码和解码。
```
import base64
s="test"
t = base64.b64encode(s)
print t
print base64.b64decode(t)
```


RC4


## Diffie–Hellman key exchange [[2]](https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B)

Diffie–Hellman key exchange，迪菲-赫尔曼密钥交换，是一种安全协议。它能够让通信双方在没有对方任何预先信息的前提下通过不安全信道进行密钥交换。它是无认证的密钥交换协议。目的是创建一个可以用于公共信道上安全通信的共享秘密（shared secret）。

![Diffie-Hellman流程图](../密码学EXM/Diffie-Hellman-Schlüsselaustausch.svg)

1. 通信双方爱丽丝A和鲍勃B两人，再通信前约定好生成元g和质数p。（此g可以被攻击者捕获）
2. 爱丽丝A随机选择一个自然数a并且将g^a mod p发送给鲍勃B。
3. 鲍勃B随机选择一个自然数b并且将g^b mod p 发送给爱丽丝A。
4. 爱丽丝A计算(g^b mod p)^a mod p。
5. 鲍勃B计算(g^a mod p)^b mod p。
6. 爱丽丝A和鲍勃B最终得到了相同的值，协商出的群元素g^(ab)作为共享密钥。



## 分组密码工作模式

分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。
常用模式有以下几块：

### 电子密码本（Electronic codebook，ECB）

### 密码块链接（CBC，Cipher-block chaining）

### 填充密码块链接 （PCBC，Propagating cipher-block chaining）

填充密码块链接 （PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining）。

### 密文反馈（CFB，Cipher feedback）

### 输出反馈模式（Output feedback, OFB）


## AEAD(Authenticated Encryption with Associated Data)

# AES

AES作为DES的升级版本，是当今主流的对称加密算法。
AES选取的分组长度为128比特，保持不变，而密钥长度可改变为128比特、192比特和256比特。
AES包括加解密(encrypt/decrypt)和轮密钥生成(key shedule)。
加解密涉及四个操作：SubBytes(字节替换)、ShiftRows(行移位)、MixColumns(列混淆)、AddRoundKey(轮密钥加)。在最后一轮不进行MixColumns。

可以参考 [FIPS 197，AES](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf)。里面有详实的标准介绍。
算法流程为：
```
Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
begin
	byte state[4,Nb]
	state = in
	AddRoundKey(state, w[0, Nb-1]) // See Sec. 5.1.4
	for round = 1 step 1 to Nr–1
		SubBytes(state) // See Sec. 5.1.1
		ShiftRows(state) // See Sec. 5.1.2
		MixColumns(state) // See Sec. 5.1.3
		AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
	end for
	SubBytes(state)
	ShiftRows(state)
	AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
	out = state
end
```
+ `State` 一个4行的矩阵，每行包括Nb个字节。用于行移位和列混淆。
+ `Nb` 组成 `State` 的列（一列4个字节，共32位）数量。这里取4。
+ `Nk` 表示密钥长度，32位字节的数量。对于128，192，256长度的密钥来说，Nk分别取4, 6, 8。
+ `Nr` 轮数量，对于128，192，256长度的密钥来说，Nr分别取10, 12, 14。

|密钥算法	|密钥长度Nk字节 | 分组长度Nb字节 | 轮数Nr |
|--------	|--------------|---------------|--------|
|AES-128	| 4 			|			 4 | 	10	|
|AES-192 	| 6				| 4				| 12	|
|AES-256 	| 8 			|4 				| 	14	|

SubBytes，将原 State中的每个字符转换成S-Box中对应下标的元素。 即 `State[i,j] = s_box[State[i,j]]` 。
```
uint8_t s_box[256] = {
	// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, // 0
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, // 1
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, // 2
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, // 3
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, // 4
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, // 5
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, // 6
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, // 7
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, // 8
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, // 9
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, // a
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, // b
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, // c
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, // d
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, // e
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};// f
```
ShiftRows，将State数组按照行 依次向左移位0字节，1字节，2字节，3字节。
```
Row0: s0  s4  s8  s12   <<< 0 byte
Row1: s1  s5  s9  s13   <<< 1 byte
Row2: s2  s6  s10 s14   <<< 2 bytes
Row3: s3  s7  s11 s15   <<< 3 bytes
```
MixColumns: 利用GF(2^8)域上算术特性的一个代替，同样用于提供算法的扩散性。
```
[02 03 01 01]   [s0  s4  s8  s12]
[01 02 03 01] . [s1  s5  s9  s13]
[01 01 02 03]   [s2  s6  s10 s14]
[03 01 01 02]   [s3  s7  s11 s15]
```
而此处的乘法和加法都是定义在GF(2^8)上的, 将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011。
乘法对加法满足分配率。
这里计算起来比较麻烦。但是如果用查表的话，速度会提升不少。
[有限域 GF(2^8) 上的乘法改用查表的方式实现](https://blog.csdn.net/lisonglisonglisong/article/details/41909813)
```
byte Mul_02[256] = {
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};
 
byte Mul_03[256] = {
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};
```

AddRoundKey, 将State和密钥进行XOR。

轮密钥生成：
```
KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
begin
	word temp
	i = 0
	while (i < Nk)
		w[i] = word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3])
		i = i+1
	end while
	i = Nk
	while (i < Nb * (Nr+1)]
		temp = w[i-1]
		if (i mod Nk = 0)
			temp = SubWord(RotWord(temp)) xor Rcon[i/Nk]
		else if (Nk > 6 and i mod Nk = 4)
			temp = SubWord(temp)
		end if
		w[i] = w[i-Nk] xor temp
		i = i + 1
	end while
end
```
1. 将128位种子密钥按照列进行排列，其中**w0**=k0 k1 k2 k3。

    
|w0 | w1| w2| w3|
|-- |--| --| ---|
|k0 |k4| k8| k12|
|k1 |k5| k9| k13|
|k2 |k6| k10| k14|
|k3 |k7| k11| k15|

2. 设j是整数并且j属于[4, 43]，若j%4=0,w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]。
	w[j]是前一列w[j-1]与上一轮w[j-Nb]异或的结果，如果是首列j%4==0，那么需要对它前一列w[j-1]做g(w)处理。
3. 函数g(w)的操作为
    1. 将w循环左移8位。（仅对w循环）
    2. 分别对w的4个字节做S盒(S-Box)置换；
    3. 与32比特的常量（RC[j/4],0,0,0）进行异或。Rc={0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}

AES加密算法的动态演示
<https://coolshell.cn/wp-content/uploads/2010/10/rijndael_ingles2004.swf>

解密的话也需要四个步骤：InvShiftRows(逆行移位), InvSubBytes(逆字节替换),InvMixColumns(逆列混淆),和 AddRoundKey(轮密钥加)。
但是解密的顺序略有不同。 `w` 为轮密钥。


```
InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
begin
	byte state[4,Nb]
	state = in
	AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1]) // See Sec. 5.1.4
	for round = Nr-1 step -1 downto 1
		InvShiftRows(state) // See Sec. 5.3.1
		InvSubBytes(state) // See Sec. 5.3.2
		AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
		InvMixColumns(state) // See Sec. 5.3.3
	end for
	InvShiftRows(state)
	InvSubBytes(state)
	AddRoundKey(state, w[0, Nb-1])
	out = state
end
```

InvShiftRows 只是将 State序列按照 行号， 进行逆向向右依次移动0个字节、1个字节、2个字节、3个字节。
```
		state
Row0: s0  s4  s8  s12   >>> 0 byte
Row1: s1  s5  s9  s13   >>> 1 byte
Row2: s2  s6  s10 s14   >>> 2 bytes
Row3: s3  s7  s11 s15   >>> 3 bytes
```
InvSubBytes 字节替换用到的逆序S-Box为：
```
	// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, // 0
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, // 1
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, // 2
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, // 3
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, // 4
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, // 5
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, // 6
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, // 7
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, // 8
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, // 9
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, // a
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, // b
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, // c
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, // d
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, // e
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};// f
```

InvMixColumns 是 MixColumns的逆序，需要用到的矩阵相乘系数为
```
[0e 0b 0d 09]   [s0  s4  s8  s12]
[09 0e 0b 0d] . [s1  s5  s9  s13]
[0d 09 0e 0b]   [s2  s6  s10 s14]
[0b 0d 09 0e]   [s3  s7  s11 s15]
```
[有限域 GF(2^8) 上的乘法改用查表的方式实现](https://blog.csdn.net/lisonglisonglisong/article/details/41909813)
```
byte Mul_09[256] = {
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};
 
byte Mul_0b[256] = {
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};
 
byte Mul_0d[256] = {
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};
 
byte Mul_0e[256] = {
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};

```

解密的AddRoundKey 与 加密的相同，只是将State和密钥做XOR操作。

## 参考
[aes算法实现](https://github.com/openluopworld/aes_128/blob/master/aes.c)
[aes算法实现](https://github.com/dhuertas/AES/blob/master/aes.c)
# RSA

给定一个正整数m，以及两个整数a,b，如果a-b被m整除，则称a与b模m同余，记作 $ a=b \pmod {m} $，否则称a与b模m不同余，记作 $ a \neq b \pmod {m} $。

**欧拉函数**
意义是求跟某个数互素，且小于这个数的元素的个数。设数n，那么 $\phi(n)=|Z_n^*|$ 。  
与n互素且小于n的任意一个数，在计算模n的幂次的时候，等于1的那个最小的幂次。  
即 $ gcd(a,n)=1 $，那么$ a^{\phi(n)}=1 \pmod {n} $。

## RSA算法流程

1. 随机生成等二进制长度的两个素数: p、q；
2. 计算 $\phi(n)=(p-1)\*(q-1)$，$n=p\*q$；
3. 随机取值e，使e与 $\phi(n)$ 互素；
4. 计算e对 $\phi(n)$ 的模逆，$e*d=1\pmod {\phi(n)}$；
5. (e, n)为公钥，(d, n)为私钥。

## 公钥加密

$$ C = M^e mod n $$


## 私钥解密

$$ M = C^d mod n $$


# Paillier同态加密算法(Paillier Homomorphic Encryption)

Paillier加密系统是概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。

# 离散对数体系（Discrete Logarithm）

实现离散对数体制的最常用的群是有限域的乘法群的循环子群和椭圆曲线群的循环子群。

## D-H

第一个离散对数体制是Diffie-Hellman于1976年提出的密钥协商协议。1984年，ElGamal提出了离散对数公钥加密方案和离散对数签名方案。以后，人们相机提出了离散对数公钥密码的各种变种。
下面介绍基本的ElGamal公钥加密方案和密钥签名方案（DSA）。

### 原根

`模除`（又称模数、取模操作、取模运算等，英语： `modulo` 有时也称作 `modulus`）得到的是一个数除以另一个数的余数。


## ElGamal加密算法

定义可以参见<https://ctf-wiki.github.io/ctf-wiki/crypto/signature/elgamal/>

非常详细的ElGamal加密的教程，给了循环组的例子。
<https://ritter.vg/security_adventures_elgamal.html>

ElGamal加密算法是一个基于 Diffie-Hellman 密钥交换的非对称加密算法。
ElGamal加密算法由三部分组成：密钥生成、加密和解密。

### 密钥生成
密钥生成的步骤如下：

+ Alice利用生成元  ${g}$ 产生一个大素数 $q$,即$g$是$q$的本原根，阶循环群 $G$的有效描述，该循环群的阶为 $q-1$。该循环群需要满足一定的安全性质。[ [本原根的概念对应模q乘法群(需循环群)中的生成元。]]
+ Alice从 $\lbrace1,\ldots ,q-1\rbrace$中随机选择一个 $x$。
+ Alice计算 $h:=g^{x}$。
+ Alice公开 $h$,以及 $G,q,g$的描述作为其公钥，并保留 $x$ 作为其私钥。私钥必须保密。

### 加密

使用Alice的公钥 $(G,q,g,h)$向她加密一条消息 $m$ 的加密算法工作方式如下：

+ Bob从 $\lbrace1,\ldots ,q-1\rbrace$ 随机选择一个 $y$，然后计算 $c_{1}:=g^{y}$。
+ Bob计算共享秘密 $s:=h^{y}$。
+ Bob把他要发送的秘密消息 $m$ 映射为 $G$ 上的一个元素 $m'$。
+ Bob计算 $c_{2}:=m'\cdot s$。
+ Bob将密文 $(c\_{1},c_{2})=(g^{y},m'\cdot h^{y})=(g^{y},m'\cdot (g^{x})^{y})$发送给Alice。

值得注意的是，如果一个人知道了 $m'$，那么它很容易就能知道 $h^{y}$的值。因此对每一条信息都产生一个新的 $y$ 可以提高安全性。所以 $y$ 也被称作临时密钥。

### 解密

利用私钥 $x$ 对密文 $(c\_{1},c_{2})$进行解密的算法工作方式如下：

+ Alice计算共享秘密 $s:=c\_{1}{}^{x}$
然后计算 $m':=c\_{2}\cdot s^{-1}$，并将其映射回明文 $m$，其中 $s^{-1}$ 是 $s$ 在群 $G$ 上的逆元。（例如：如果 $G$ 是整数模n乘法群的一个子群，那么逆元就是模逆元）。
解密算法是能够正确解密出明文的，因为
$c\_{2}\cdot s^{-1}=m'\cdot h^{y}\cdot (g^{xy})^{-1}=m'\cdot g^{xy}\cdot g^{-xy}=m'.$

同样参考 [ElGamal加密算法](https://www.jianshu.com/p/cd36ae7dca47)

## ElGamal签名算法

ElGamal 来说，其签名方案与相应的加密方案具有很大区别。

**补充**： 在同余理论中，模 n 的互质同余类组成一个乘法群，称为整数模 n 乘法群。
> In modular arithmetic, the integers coprime (relatively prime) to n from the set {0,1,... ,n-1} of n non-negative integers form a group under multiplication modulo n, called the multiplicative group of integers modulo n.

**补充**：
扩展欧几里得算法（英语：Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式

$ ax + by = \gcd(a, b)$

### 密钥生成

1. 选取一个足够大的素数 $p$（十进制位数不低于 160），以便于在$Z_p$上求解离散对数问题是困难的。
2. 选取整数模 $p$ 乘法群$Z_{p}^{*}$ 的生成元 $g$。
3. 随机选取密钥 $x$，满足 $1 < x < p − 2$，计算 $y = g^x mod p$ 。

其中私钥为 ${d}$，公钥为 ${p,g,y}$ 。

### 签名

如果A 要对消息 $m$ 进行签名 $sig_d(m,k)=(r,s)$ ，过程为：
1.  选取随机数 $k$ ，满足 $1 < k < p − 1$ ，并且 $gcd(k,p-1)=1$。
2. 计算  $r\,\equiv \,g^{k}{\pmod {p}}$
3. 利用扩展欧几里得公式 $m \, \equiv \, x r + s k \pmod{p-1}$，计算 $s\,\equiv \,(m-xr)k^{-1}{\pmod {p-1}}$ 。
4. 如果 $s=0$ ， 重新计算。

对 $m$ 的签名结果为 $(r,s)$ 。

### 验证
B拿到消息和消息的签名结果验证阶段：
如果 $g^m\, \equiv \, y^{r}r^{s} {\pmod {p}}$ ，那么验证成功，否则验证失败。

由于 $m \, \equiv \, x r + s k \pmod{p-1}$
$$
\begin{align}
g^{m} & \equiv g^{xr} g^{ks} \\
& \equiv (g^{x})^r (g^{k})^s \\
& \equiv (y)^r (r)^s \pmod p.\\
\end{align}$$



## DSA -Digital Signature Algorithm
Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。 专门用于签名和验签。
DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。

### 密钥生成 

密钥生成有两个阶段。  
第一阶段，是公开的参数信息。
1. 选择一个合适的哈希函数 $H$，目前一般选择 SHA1，当前也可以选择强度更高的哈希函数 如 SHA2。
2. 选择密钥的长度 $L$ 和 $N$，这两个值决定了签名的安全程度。在最初的 DSS（Digital Signature Standard ）中建议 $L$ 必须为 64 的倍数，并且 $512 ≤ L ≤ 1024$，当然，也可以更大。 $N$ 必须不大于哈希函数 $H$ 输出的长度。FIPS 186-3 给出了一些建议的 L 和 N 的取值例子：(1024, 160)， (2048, 224)， (2048, 256)，以及 (3,072, 256)。
3. 选择 $N$ 比特的素数 $q$ , $N$ 长度小于或等于哈希函数输出长度。
4. 选择 $L$ 比特的素数 $p$，使得 $p-1$ 是 $q$ 的倍数。
5. 选择 $g$ ，其模$p$ 的乘阶为 $q$ ，意味着 $q$ 是满足  $g^q=1\pmod p$ 最小的正整数，即 $ord_p(g)=p$。 即 $g$ 在模 $p$ 的意义下，其指数次幂可以生成具有 $q$ 个元素的子群。这里，我们可以通过计算 $g = h^ {\frac {p − 1} {q} }\pmod {p}$ 来得到 $g$，其中 $1 < h < p − 1$ 。 大部分的 $h$ 选择会导致可使用的 $g$ ，通常 $h=2$ 。

$(p, g, q)$会在不同的系统间公开。
第二阶段，计算公钥和私钥。
选择私钥 $x$，使其满足 $0 < x < q$ ，计算 $y ≡ g^x mod p$ 。  
公钥为 $(p, q, g, y)$ 。

### 签名

1. 选择随机整数数 k 作为*临时密钥*， $ 0 < k < q $。 
2. 计算 $r ≡ (g^k \pmod {p} ) \pmod {q} $
3. 计算 $s ≡ (H(m) + x r ) k^{−1} \pmod {q}$ 。

签名结果为 $(r,s)$。**需要注意的是，这里与 Elgamal 很重要的不同是这里使用了哈希函数对消息进行了哈希处理**。

可以利用扩展欧几里得算法计算 模逆 $k^{−1} \pmod {q}$ ，或者使用费马小定理。

由于签名者 既不知道 私钥 $x$ ，又不知道随机数 $k$ ，在验证 $s ≡ (H(m) + x r ) k^{−1} \pmod {q}$ 时，需要将其转换成 $ k ≡ (H(m) + x r ) s^{−1} \pmod {q} $ 。  
两边作 $g$ 的幂指数，得到 $ g^k ≡ g^{H(m)k^{-1}}y^{rs^{-1}} \pmod {p}$ 。 所以，验签者可以计算等式右边，等式左边是 $r$ ，那么可以判断等式是否成立。

### 验证

1. 先判断 $ 0 < r <q $ 或者 $ 0 < s < q $ 是否满足条件，如果不满足，则不验签。
2. 计算 $w=s^{-1}{\bmod {\,}}q $
3. 计算 $ u_{1}=H\left(m\right)\cdot w\,{\bmod {\,}}q $
4. 计算 $ u_{2}=r\cdot w\,{\bmod {\,}}q $
5. 计算 $ v=\left(g^{u\_{1}}y^{u\_{2}}{\bmod {\,}}p\right){\bmod {\,}}q $

如果 $ v = r $ ， 那么签名有效。

### 正确性证明



签名者计算 $$ s ≡ (H(m) + x r ) k^{−1} \pmod {q}$$ ，
可得
$$
\begin{align}
k & \equiv H(m)s^{-1}+xrs^{-1}\\
  & \equiv H(m)w + xrw \pmod{q}
\end{align}
$$

费马小定理 $ g^q ≡ h^{p − 1} ≡ 1 \pmod {p} $ ，且 $ g >1 $ , $q$ 是质数， 因此 $g$ 有 $q \pmod{p}$ 阶。  
$$
\begin{align}
g^{k}&\equiv g^{H(m)w}g^{xrw}\\
	&\equiv g^{H(m)w}y^{rw}\\
	&\equiv g^{u\_{1}}y^{u\_{2}}{\pmod {p}}
\end{align}
$$

DSA的正确性可从下式得出：
$$
\begin{align}
r&=(g^{k}{\bmod {\,}}p){\bmod {\,}}q\\
&=(g^{u\_{1}}y^{u\_{2}}{\bmod {\,}}p){\bmod {\,}}q\\
&=v
\end{align}
$$

## ECDSA

随机数很重要！
> The ECDSA digital signature has a drawback compared to RSA in that it requires a good source of entropy.   
Without proper randomness, the private key could be revealed.  
A flaw in the random number generator on Android allowed hackers to find the ECDSA private key used to protect the bitcoin wallets of several people in early 2013.   
Sony's Playstation implementation of ECDSA had a similar vulnerability.   
A good source of random numbers is needed on the machine making the signatures. Dual_EC_DRBG is not recommended.

from [A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)
# 国产密码算法

国产密码算法（国密算法）是指国家密码局认定的`国产商用密码算法`，在金融领域目前主要使用公开的SM2、SM3、SM4三类算法，分别是非对称算法、哈希算法和对称算法。 其中`SM`代表“商密”，即用于商用的、不涉及国家秘密的密码技术。

## SM2椭圆曲线公钥密码算

SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括SM2-1椭圆曲线数字签名算法，SM2-2椭圆曲线密钥交换协议，SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。

## SM3杂凑算法
SM3杂凑算法是我国自主设计的密码杂凑算法，适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短，例如MD5输出128比特杂凑值，输出长度太短，影响其安全性SHA-1算法的输出长度为160比特，SM3算法的输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。

## SM4分组密码算法

SM4分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密/解密运算，以保证数据和信息的机密性。要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度分组长度128比特，因此在安全性上高于3DES算法。

## 祖冲之序列密码算法



# 参考文献
1. [安全体系（一）—— DES算法详解](http://www.cnblogs.com/songwenlong/p/5944139.html)
2. [迪菲-赫尔曼密钥交换](https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B)
3. [分组密码工作模式](https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)
4. [密码算法详解——AES](http://www.cnblogs.com/luop/p/4334160.html)
5. [密码标准应用指南](http://www.gmbz.org.cn/upload/2018-03-24/1521879142922000396.pdf)


